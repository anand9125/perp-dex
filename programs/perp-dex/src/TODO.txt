use anchor_lang::prelude::*;

/// Number of request slots in the queue
pub const MAX_REQUESTS: usize = 1024;

declare_id!("ReqQue1111111111111111111111111111111111111");

#[program]
pub mod perpx_request_queue {
    use super::*;

    pub fn initialize_request_queue(ctx: Context<InitializeRequestQueue>) -> Result<()> {
        let mut queue = ctx.accounts.request_queue.load_init()?;
        queue.head = 0;
        queue.tail = 0;
        queue.count = 0;
        queue.capacity = MAX_REQUESTS as u64;
        Ok(())
    }

    pub fn push_request(ctx: Context<PushRequest>, req_data: RequestData) -> Result<()> {
        let mut queue = ctx.accounts.request_queue.load_mut()?;

        require!(queue.count < queue.capacity, ErrorCode::QueueFull);

        let idx = (queue.tail % queue.capacity) as usize;

        queue.requests[idx] = Request {
            request_type: req_data.request_type,
            owner: ctx.accounts.owner.key(),
            market: req_data.market,
            order_id: req_data.order_id,
            side: req_data.side,
            price: req_data.price,
            amount: req_data.amount,
            timestamp: Clock::get()?.unix_timestamp,
        };

        queue.tail += 1;
        queue.count += 1;

        Ok(())
    }

    // Used by off-chain crank to consume the queue
    pub fn consume_request(ctx: Context<ConsumeRequest>, limit: u64) -> Result<()> {
        let mut queue = ctx.accounts.request_queue.load_mut()?;

        let mut processed = 0u64;

        while processed < limit && queue.count > 0 {
            let idx = (queue.head % queue.capacity) as usize;
            let req = queue.requests[idx];

            // TODO: off-chain crank should handle the real logic like:
            // match_orders, cancel, liquidate, etc.
            // On-chain here we just simulate removal.

            msg!(
                "Processing request {:?} order_id={:?} owner={:?}",
                req.request_type,
                req.order_id,
                req.owner
            );

            queue.head += 1;
            queue.count -= 1;
            processed += 1;
        }

        Ok(())
    }
}

















#[derive(Accounts)]
pub struct InitializeRequestQueue<'info> {
    #[account(
        init,
        payer = payer,
        space = 8 + RequestQueue::SIZE,
        seeds = [b"request_queue"],
        bump,
    )]
    pub request_queue: AccountLoader<'info, RequestQueue>,
    #[account(mut)]
    pub payer: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct PushRequest<'info> {
    #[account(mut)]
    pub request_queue: AccountLoader<'info, RequestQueue>,
    #[account(mut)]
    pub owner: Signer<'info>,
}

#[derive(Accounts)]
pub struct ConsumeRequest<'info> {
    #[account(mut)]
    pub request_queue: AccountLoader<'info, RequestQueue>,
}

/// Zero-copy request queue
#[account(zero_copy)]
pub struct RequestQueue {
    pub head: u64,       // index for crank to read
    pub tail: u64,       // index for users to write
    pub count: u64,      // current active requests
    pub capacity: u64,   // total slots
    pub requests: [Request; MAX_REQUESTS],
}

impl RequestQueue {
    pub const SIZE: usize =
        8 * 4 + (Request::SIZE * MAX_REQUESTS); // metadata + all request entries
}

#[zero_copy]
#[derive(Default, AnchorSerialize, AnchorDeserialize, Debug, PartialEq, Eq, Copy, Clone)]
pub struct Request {
    pub request_type: RequestType,
    pub owner: Pubkey,
    pub market: Pubkey,
    pub order_id: u128,
    pub side: Side,
    pub price: u64,
    pub amount: u64,
    pub timestamp: i64,
}

impl Request {
    pub const SIZE: usize = 1 + 32 + 32 + 16 + 1 + 8 + 8 + 8;
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy, Debug, PartialEq, Eq)]
pub struct RequestData {
    pub request_type: RequestType,
    pub market: Pubkey,
    pub order_id: u128,
    pub side: Side,
    pub price: u64,
    pub amount: u64,
}

#[repr(u8)]
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy, Debug, PartialEq, Eq)]
pub enum RequestType {
    PlaceOrder = 0,
    CancelOrder = 1,
    Liquidate = 2,
}

#[repr(u8)]
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy, Debug, PartialEq, Eq)]
pub enum Side {
    Bid = 0,
    Ask = 1,
}
